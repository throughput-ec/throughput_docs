{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Throughput DB documentation! \u00b6 This is documentation for the Throughput Database proper. It documents the ways in which the database is built and the node and relationship types within the database. Use the menu bar above to navigate through the site. Data Elements discuss particular node types within the neo4j database. Data Models discuss more complex object types within the database, such as \"Linking Code Repositories\" and \"Data Annotations\". Contribution \u00b6 This is open documentation, built using mkdocs using plain-text markdown files. Contributors are welcome. You can find out more about the documentation and the Code of Contribution at the project GitHub repository . This figure shows an annotation generated that links an existing research database to a code repository that uses or references that database. To search the database visit the Throughput Website .","title":"Home"},{"location":"#throughput-db-documentation","text":"This is documentation for the Throughput Database proper. It documents the ways in which the database is built and the node and relationship types within the database. Use the menu bar above to navigate through the site. Data Elements discuss particular node types within the neo4j database. Data Models discuss more complex object types within the database, such as \"Linking Code Repositories\" and \"Data Annotations\".","title":"Throughput DB documentation!"},{"location":"#contribution","text":"This is open documentation, built using mkdocs using plain-text markdown files. Contributors are welcome. You can find out more about the documentation and the Code of Contribution at the project GitHub repository . This figure shows an annotation generated that links an existing research database to a code repository that uses or references that database. To search the database visit the Throughput Website .","title":"Contribution"},{"location":"admin/loading/","text":"Cloning the Throughput Database \u00b6 The Throughput Database is a live database, that is continually updated with user-created annotations and operations that clean and optimize the graph structure. Database snapshots are made available on a semi-regular basis and can be accessed through the Throughput Snapshot Collection on figShare. Download the File \u00b6 The Throughput snapshots are saved as tar.gz compressed files. A number of programs exist to unzip these files on Windows, Mac or Linux operating systems. Select one of the snapshots within the Collection and download the file to your computer. Using neo4j Desktop \u00b6 The file within the tar.gz archive is a neo4j dump file . If you do not have neo4j installed, you must do that first (see Installing neo4j ). Once neo4j is installed: Start Neo4j desktop and create a new local database. Click on the ... icon on the top right of the database panel, and select Manage . Click the \"Open Folder\" button to open the directory of the database. Move the .dump file to this directory. In the Manage window, click the Open Terminal button. In the terminal, use the following command: bin/neo4j-admin load --from=<archive-path> --database=<database-name> --force Where the <archive-path> is the full path of the .dump file and <database-name> is the name of the new database that you created. There may be some difference between Windows and Linux-based operating systems in the use of forward and backslashes. If you are running into problems, you can try: bin\\neo4j-admin load --from=data/backups/neo4j.dump --database=neo4j --force Start the database. It should populate with the data.","title":"Installing"},{"location":"admin/loading/#cloning-the-throughput-database","text":"The Throughput Database is a live database, that is continually updated with user-created annotations and operations that clean and optimize the graph structure. Database snapshots are made available on a semi-regular basis and can be accessed through the Throughput Snapshot Collection on figShare.","title":"Cloning the Throughput Database"},{"location":"admin/loading/#download-the-file","text":"The Throughput snapshots are saved as tar.gz compressed files. A number of programs exist to unzip these files on Windows, Mac or Linux operating systems. Select one of the snapshots within the Collection and download the file to your computer.","title":"Download the File"},{"location":"admin/loading/#using-neo4j-desktop","text":"The file within the tar.gz archive is a neo4j dump file . If you do not have neo4j installed, you must do that first (see Installing neo4j ). Once neo4j is installed: Start Neo4j desktop and create a new local database. Click on the ... icon on the top right of the database panel, and select Manage . Click the \"Open Folder\" button to open the directory of the database. Move the .dump file to this directory. In the Manage window, click the Open Terminal button. In the terminal, use the following command: bin/neo4j-admin load --from=<archive-path> --database=<database-name> --force Where the <archive-path> is the full path of the .dump file and <database-name> is the name of the new database that you created. There may be some difference between Windows and Linux-based operating systems in the use of forward and backslashes. If you are running into problems, you can try: bin\\neo4j-admin load --from=data/backups/neo4j.dump --database=neo4j --force Start the database. It should populate with the data.","title":"Using neo4j Desktop"},{"location":"agents/agents/","text":"AGENTs \u00b6 Agents are the people or things that do the work of creating ANNOTATION s in the Throughput Annotation Database. An agent may be a person, software, an organization, or may be another AGENTTYPE that is either undefined, or that is to be implemented. An agent can Create or Generate an annotation. The difference being that Generated annotations are programmatically produced, and as such should be limited to AGENT s with the AGENTTYPE property {type:SoftwareAgent} . We can search for ANNOTATION s generated by specific AGENT s, or that reference OBJECTS associated with individuals or pieces of software. For example, we may want to find all annotations generated by the Throughput Widget API, or all annotations by a graduate student who had been working with a particular database. Matching AGENT s \u00b6 Matching an AGENT is fairly straightforward. We can match: MATCH (ag:AGENT) WHERE ag.name CONTAINS('Simon') RETURN properties(ag) At the time of writing, this returns 360 separate records of individuals. From that point we can make more complex queries, for example, counting the number of annotations each of those individuals is associated with: MATCH (ag:AGENT) WHERE ag.name CONTAINS('Simon') WITH ag MATCH (ag)-[:Created]->(an:ANNOTATION) RETURN ag.name, COUNT(DISTINCT an) At this time, only one individual named Simon has contributed annotations. AGENTTYPEs \u00b6","title":"AGENTs"},{"location":"agents/agents/#agents","text":"Agents are the people or things that do the work of creating ANNOTATION s in the Throughput Annotation Database. An agent may be a person, software, an organization, or may be another AGENTTYPE that is either undefined, or that is to be implemented. An agent can Create or Generate an annotation. The difference being that Generated annotations are programmatically produced, and as such should be limited to AGENT s with the AGENTTYPE property {type:SoftwareAgent} . We can search for ANNOTATION s generated by specific AGENT s, or that reference OBJECTS associated with individuals or pieces of software. For example, we may want to find all annotations generated by the Throughput Widget API, or all annotations by a graduate student who had been working with a particular database.","title":"AGENTs"},{"location":"agents/agents/#matching-agents","text":"Matching an AGENT is fairly straightforward. We can match: MATCH (ag:AGENT) WHERE ag.name CONTAINS('Simon') RETURN properties(ag) At the time of writing, this returns 360 separate records of individuals. From that point we can make more complex queries, for example, counting the number of annotations each of those individuals is associated with: MATCH (ag:AGENT) WHERE ag.name CONTAINS('Simon') WITH ag MATCH (ag)-[:Created]->(an:ANNOTATION) RETURN ag.name, COUNT(DISTINCT an) At this time, only one individual named Simon has contributed annotations.","title":"Matching AGENTs"},{"location":"agents/agents/#agenttypes","text":"","title":"AGENTTYPEs"},{"location":"keywords/keywords/","text":"KEYWORDs \u00b6 A KEYWORD can be associated with any ANNOTATION . A common use would be to help discover an OBJECT associated with a keyword such as climate or cheese . Keywords could be associated with an AGENT or any other node type, but a KEYWORD is always connected through an ANNOTATION . In this way, a KEYWORD may be associated with another KEYWORD through a synonymy which would be represented as indicated below. Matching Keywords \u00b6 We often want to do a simple keyword search. MATCH (k:KEYWORD {keyword: $userkw}) MATCH (k)<-[:hasKeyword]-(a:ANNOTATION) MATCH (a)-[:Target]->(ob:OBJECT) MATCH (ob)-[:isType]->(ty:TYPE) MATCH (a)-[:Body]->(obb:OBJECT) RETURN properties(ob), ty.type, obb.value This returns all objects (of any kind) associated with that keyword, the type of object ( ty.type ), and then the annotation text used to create the keyword link. It may be that some keywords come from an authority (for example, the database or code repository has defined them directly), and others may have been added by a Throughput user. Each ANNOTATION is tagged by the AGENT who Created the annotation, and the AGENT (most commonly a SoftwareAgent ) who Generated the ANNOTATION . This means we can also filter by AGENT or add the AGENT information to the query to get better information about the keyword relation. SYNONYMY \u00b6 There are cases where assigned keywords may be too precise, or have spelling errors. To account for this we can also use a synonymy. Synonymy is indicated by the relationship isSynonym connecting two KEYWORD elements through an ANNOTATION . This format allows us to have a TextBody OBJECT that contains information about why the synonymy was generated, and the agent who generated that synonymy. Matching with Synonyms \u00b6 In this case we can match by: MATCH (k:KEYWORD {keyword: $userkw}) OPTIONAL MATCH (syn:KEYWORD)<-[:isSynonym]-(:ANNOTATION)-[:isSynonym]->(k) WITH COLLECT(syn) + COLLECT(k) AS kws MATCH (kws)<-[:hasKeyword]-(a:ANNOTATION) MATCH (a)-[:Target]->(ob:OBJECT) MATCH (ob)-[:isType]->(ty:TYPE) MATCH (a)-[:Body]->(obb:OBJECT) RETURN properties(ob), ty.type, obb.value This will look for all keywords and keyword synonyms, and then find all objects associated with them. Again, we can filter by TYPE , AGENT or other elements to get a better subset of results.","title":"KEYWORDs"},{"location":"keywords/keywords/#keywords","text":"A KEYWORD can be associated with any ANNOTATION . A common use would be to help discover an OBJECT associated with a keyword such as climate or cheese . Keywords could be associated with an AGENT or any other node type, but a KEYWORD is always connected through an ANNOTATION . In this way, a KEYWORD may be associated with another KEYWORD through a synonymy which would be represented as indicated below.","title":"KEYWORDs"},{"location":"keywords/keywords/#matching-keywords","text":"We often want to do a simple keyword search. MATCH (k:KEYWORD {keyword: $userkw}) MATCH (k)<-[:hasKeyword]-(a:ANNOTATION) MATCH (a)-[:Target]->(ob:OBJECT) MATCH (ob)-[:isType]->(ty:TYPE) MATCH (a)-[:Body]->(obb:OBJECT) RETURN properties(ob), ty.type, obb.value This returns all objects (of any kind) associated with that keyword, the type of object ( ty.type ), and then the annotation text used to create the keyword link. It may be that some keywords come from an authority (for example, the database or code repository has defined them directly), and others may have been added by a Throughput user. Each ANNOTATION is tagged by the AGENT who Created the annotation, and the AGENT (most commonly a SoftwareAgent ) who Generated the ANNOTATION . This means we can also filter by AGENT or add the AGENT information to the query to get better information about the keyword relation.","title":"Matching Keywords"},{"location":"keywords/keywords/#synonymy","text":"There are cases where assigned keywords may be too precise, or have spelling errors. To account for this we can also use a synonymy. Synonymy is indicated by the relationship isSynonym connecting two KEYWORD elements through an ANNOTATION . This format allows us to have a TextBody OBJECT that contains information about why the synonymy was generated, and the agent who generated that synonymy.","title":"SYNONYMY"},{"location":"keywords/keywords/#matching-with-synonyms","text":"In this case we can match by: MATCH (k:KEYWORD {keyword: $userkw}) OPTIONAL MATCH (syn:KEYWORD)<-[:isSynonym]-(:ANNOTATION)-[:isSynonym]->(k) WITH COLLECT(syn) + COLLECT(k) AS kws MATCH (kws)<-[:hasKeyword]-(a:ANNOTATION) MATCH (a)-[:Target]->(ob:OBJECT) MATCH (ob)-[:isType]->(ty:TYPE) MATCH (a)-[:Body]->(obb:OBJECT) RETURN properties(ob), ty.type, obb.value This will look for all keywords and keyword synonyms, and then find all objects associated with them. Again, we can filter by TYPE , AGENT or other elements to get a better subset of results.","title":"Matching with Synonyms"},{"location":"models/annotation/","text":"New Annotations \u00b6 New annotations can be added by users using an API. We can add annotations in several ways. A user can use the Throughput Widget on a data repository website to annotate a particular data object, or dataset. An individual may add an annotation to link a data repository to a particular code repository, or may create an annotation that adds additional information to a particular element within the Throughput annotation graph (for example, a description, keyword or subject to an object). Annotating a Dataset \u00b6 curl Request \u00b6 curl -d '{dbid: 'r3d0000000', orcid: '0000-0000-0000-000X', additionalType: 'doi', id: '10.00000/00000000', body: 'This dataset is considered to be an outlier in Akenbata et al., 2021', token: 'XXXXXXX'}' -H 'Content-Type: application/json' https://throughputdb.com/api/widget The dataset annotation API is a POST method that accepts the following parameters: dbid , the unique database identifier; orcid , the user ORCID (for the user making the request), additionalType , this is a parameter that is implemented by the database on which the user is making the POST request, to identify at which level the annotation is being made, this is to account for potentially overlapping identifiers; id , the object identifier, associated with the additionalType and dbid ; body , the text that us to be used to annotate the object, for example, \"This dataset is considered to be an outlier in Akenbata et al., 2021\" ; token , the unique alphanumeric token that is associated with a particular database for use with the Annotation Widget. In the figure above we can see that there are two AGENT elements, one is the Widget software that was used to post the annotation, and the particular instance of this widget is identified by the token passed in the POST request. The second AGENT is the individual making the annotation, identified using their ORCID. The OBJECT of TYPE Dataset is Contain ed within the OBJECT of TYPE schema:DataCatalog , identified by the dbid passed to the POST method. The API call thus accounts for all elements needed to generate the graph for this particular annotation. DeepDive Annotations \u00b6 Tools used to extract text from full text documents can store records in the Throughput graph. This allows the document identifiers (e.g., DOIs) to then be linked to then be linked to the metadata extraction. For example, a database could build metadata stubs for dataset entries based on prior extraction from full-text documents. By then searching the graph for these annotations (using the DOI) some data entry can then be automated. In this instance spatial information is extracted from a publication ( OBJECT with TYPE schema:Article ). The annotation is placed in a TextualBody , however, this may not be the most appropriate data model . We will continue this discussion as the project develops.","title":"Annotations"},{"location":"models/annotation/#new-annotations","text":"New annotations can be added by users using an API. We can add annotations in several ways. A user can use the Throughput Widget on a data repository website to annotate a particular data object, or dataset. An individual may add an annotation to link a data repository to a particular code repository, or may create an annotation that adds additional information to a particular element within the Throughput annotation graph (for example, a description, keyword or subject to an object).","title":"New Annotations"},{"location":"models/annotation/#annotating-a-dataset","text":"","title":"Annotating a Dataset"},{"location":"models/annotation/#curl-request","text":"curl -d '{dbid: 'r3d0000000', orcid: '0000-0000-0000-000X', additionalType: 'doi', id: '10.00000/00000000', body: 'This dataset is considered to be an outlier in Akenbata et al., 2021', token: 'XXXXXXX'}' -H 'Content-Type: application/json' https://throughputdb.com/api/widget The dataset annotation API is a POST method that accepts the following parameters: dbid , the unique database identifier; orcid , the user ORCID (for the user making the request), additionalType , this is a parameter that is implemented by the database on which the user is making the POST request, to identify at which level the annotation is being made, this is to account for potentially overlapping identifiers; id , the object identifier, associated with the additionalType and dbid ; body , the text that us to be used to annotate the object, for example, \"This dataset is considered to be an outlier in Akenbata et al., 2021\" ; token , the unique alphanumeric token that is associated with a particular database for use with the Annotation Widget. In the figure above we can see that there are two AGENT elements, one is the Widget software that was used to post the annotation, and the particular instance of this widget is identified by the token passed in the POST request. The second AGENT is the individual making the annotation, identified using their ORCID. The OBJECT of TYPE Dataset is Contain ed within the OBJECT of TYPE schema:DataCatalog , identified by the dbid passed to the POST method. The API call thus accounts for all elements needed to generate the graph for this particular annotation.","title":"curl Request"},{"location":"models/annotation/#deepdive-annotations","text":"Tools used to extract text from full text documents can store records in the Throughput graph. This allows the document identifiers (e.g., DOIs) to then be linked to then be linked to the metadata extraction. For example, a database could build metadata stubs for dataset entries based on prior extraction from full-text documents. By then searching the graph for these annotations (using the DOI) some data entry can then be automated. In this instance spatial information is extracted from a publication ( OBJECT with TYPE schema:Article ). The annotation is placed in a TextualBody , however, this may not be the most appropriate data model . We will continue this discussion as the project develops.","title":"DeepDive Annotations"},{"location":"models/data_models/","text":"Data Models \u00b6 Currently there are several models for relationships within Throughput: Data Use and Reuse Databases linked to code repositories Papers linked to GitHub code repositories Text annotations linked to datasets (linked to databases) Credit tracking Grants linked to databases Grants linked to code repositories Grants linked to papers Data Use and Reuse \u00b6 Throughput aims to help people find ways to use data that meet their needs as a researcher. For example, we want to help early-career researchers find ways to undertake multidisciplinary analysis that combines climate data and information about land use. To do this, a student must find the appropriate data resources and then understand how to undertake analysis on these resources. Data(base)-to-Code Connections \u00b6 A research database may have many uses, through APIs, direct data downloads, or SQL connections to the databases. Throughput links to each repository that uses a particular data resource. This code is publicly available at the Throughput re3 scraper repository . Using schema:DataCatalog OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Sample Query \u00b6 # Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:DataCatalog\"}) WHERE n.name CONTAINS \"searchTerm\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10 Paper-to-Code Connections \u00b6 Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Article OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Sample Query \u00b6 # Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:Article\"}) WHERE n.doi CONTAINS \"10.1002/ecy.2856\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10 Text-to-Dataset Connections \u00b6 Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Dataset OBJECT nodes we can create an annotation that links to a TextualBody OBJECT . The ANNOTATION node identifies the link between the two records. This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE . Credit Tracking \u00b6","title":"Data Models"},{"location":"models/data_models/#data-models","text":"Currently there are several models for relationships within Throughput: Data Use and Reuse Databases linked to code repositories Papers linked to GitHub code repositories Text annotations linked to datasets (linked to databases) Credit tracking Grants linked to databases Grants linked to code repositories Grants linked to papers","title":"Data Models"},{"location":"models/data_models/#data-use-and-reuse","text":"Throughput aims to help people find ways to use data that meet their needs as a researcher. For example, we want to help early-career researchers find ways to undertake multidisciplinary analysis that combines climate data and information about land use. To do this, a student must find the appropriate data resources and then understand how to undertake analysis on these resources.","title":"Data Use and Reuse"},{"location":"models/data_models/#database-to-code-connections","text":"A research database may have many uses, through APIs, direct data downloads, or SQL connections to the databases. Throughput links to each repository that uses a particular data resource. This code is publicly available at the Throughput re3 scraper repository . Using schema:DataCatalog OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Data(base)-to-Code Connections"},{"location":"models/data_models/#sample-query","text":"# Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:DataCatalog\"}) WHERE n.name CONTAINS \"searchTerm\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10","title":"Sample Query"},{"location":"models/data_models/#paper-to-code-connections","text":"Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Article OBJECT nodes we can create an annotation that links to a schema:CodeRepository OBJECT . The ANNOTATION node identifies the link between the two records, and can be supplemented with an OBJECT node of TYPE TextualBody . This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Paper-to-Code Connections"},{"location":"models/data_models/#sample-query_1","text":"# Search for all code repositories linked to a database: MATCH (n:OBJECT)-[:isType]-(:TYPE {type:\"schema:Article\"}) WHERE n.doi CONTAINS \"10.1002/ecy.2856\" MATCH (o:OBJECT)-[:isType]-(:TYPE {type:\"schema:CodeRepository\"}) WITH n, o MATCH p=(n)-[]-(:ANNOTATION)-[:Target]-(o) RETURN p LIMIT 10","title":"Sample Query"},{"location":"models/data_models/#text-to-dataset-connections","text":"Research papers contain detailed methodologies that are supported by peer reviewed literature. This supporting information may be lost when users rely only on the code. By linking code in code repositories to published articles, and the published articles to the code repositories, we make both more discoverable, and provide a clear link, and attribution to the citation itself. Using schema:Dataset OBJECT nodes we can create an annotation that links to a TextualBody OBJECT . The ANNOTATION node identifies the link between the two records. This last object has an explanation of why the annotation was made. The annotation includes information about the AGENT that has generated the annotation. This may include either an individual who created the specific annotation, or a set of annotations generated programatically. The AGENT can be identified using the AGENTTYPE .","title":"Text-to-Dataset Connections"},{"location":"models/data_models/#credit-tracking","text":"","title":"Credit Tracking"},{"location":"nodes/objects/","text":"OBJECTs \u00b6 Objects are the powerhouse of Throughput. They are the elements that are linked by annotations. The main object classes in Throughput are grants, code repositories and databases. Objects are defined by TYPE classes. A TYPE is defined either through the types defined in the W3C Annotation documentation, or by a set of definitions from schema.org . All objects have a unique ID (imposed by neo4j), and may have a second ID that is defined by the object type. NOTE: The parameter id associated with some OBJECT nodes is not the same as the values obtained using the cypher statement id(node) . Using id(node) returns the internal identity value for the node as implemented by neo4j. An OBJECT in the database may be connected to a TYPE ( isType ) or an ANNOTATION ( Body or Target ). Matching Objects \u00b6 An OBJECT may have one or more properties, not all OBJECT s have the same properties. For example, a TextualBody object will (most likely) not have a doi associated with it. Some common properties of OBJECT s are url s, id s, and name elements. A simple OBJECT match may be: MATCH (o:OBJECT) WHERE o.name CONTAINS('Neotoma') RETURN o Constraints & Indexes \u00b6 Object ids must be unique & are indexed: CREATE CONSTRAINT ON (o:OBJECT) ASSERT o.id IS UNIQUE; CREATE INDEX objName FOR (n:OBJECT) ON (n.name) Object names are indexed CREATE INDEX objName FOR (n:OBJECT) ON (n.name) There is a fulltext index on the name and description : CALL db.index.fulltext.createNodeIndex(\"nameAndDesc\", [\"OBJECT\"], [\"name\", \"description\"])","title":"OBJECTs"},{"location":"nodes/objects/#objects","text":"Objects are the powerhouse of Throughput. They are the elements that are linked by annotations. The main object classes in Throughput are grants, code repositories and databases. Objects are defined by TYPE classes. A TYPE is defined either through the types defined in the W3C Annotation documentation, or by a set of definitions from schema.org . All objects have a unique ID (imposed by neo4j), and may have a second ID that is defined by the object type. NOTE: The parameter id associated with some OBJECT nodes is not the same as the values obtained using the cypher statement id(node) . Using id(node) returns the internal identity value for the node as implemented by neo4j. An OBJECT in the database may be connected to a TYPE ( isType ) or an ANNOTATION ( Body or Target ).","title":"OBJECTs"},{"location":"nodes/objects/#matching-objects","text":"An OBJECT may have one or more properties, not all OBJECT s have the same properties. For example, a TextualBody object will (most likely) not have a doi associated with it. Some common properties of OBJECT s are url s, id s, and name elements. A simple OBJECT match may be: MATCH (o:OBJECT) WHERE o.name CONTAINS('Neotoma') RETURN o","title":"Matching Objects"},{"location":"nodes/objects/#constraints-indexes","text":"Object ids must be unique & are indexed: CREATE CONSTRAINT ON (o:OBJECT) ASSERT o.id IS UNIQUE; CREATE INDEX objName FOR (n:OBJECT) ON (n.name) Object names are indexed CREATE INDEX objName FOR (n:OBJECT) ON (n.name) There is a fulltext index on the name and description : CALL db.index.fulltext.createNodeIndex(\"nameAndDesc\", [\"OBJECT\"], [\"name\", \"description\"])","title":"Constraints &amp; Indexes"},{"location":"types/types/","text":"TYPEs \u00b6 TYPE is a property of an OBJECT but in practice it is defined as a separate node within the database to allow us to improve the flexibility of the underlying data model. TYPE nodes are defined either as part of the w3C Annotation model (e.g., {type:'TextualBody'} or using other schema, for example {type:'schema:CodeRepository'} . type n schema:Grant 467,000 TextualBody 356,000 schema:Article 159,000 schema:CodeRepository 74,000 schema:DataCatalog 2,300 Dataset 390 Matching Objects by Type \u00b6 Using the TYPE element we can find (for example) a database using: MATCH (tdb:TYPE {type:'schema:DataCatalog'}) MATCH (tdb)<-[:isType]-(n:OBJECT) RETURN n LIMIT 3 The TYPE defining an object also defines some of the properties that the object may have, although these are not embedded as constraints. Various TYPEs \u00b6 schema:DataCatalog \u00b6 Objects defined as data catalogs were initially scraped from re3data.org using a script that has been stored on GitHub in a code repository <http://https://github.com/throughput-ec/throughputdb/tree/master/Re3Databases> _. The object has properties: id , which come from the unique identifier (DOI) assigned by re3data. name is the official name of the database. url is the URL link for the database. keywords is an array of terms associated with the database (although see keywords ) description is the description given to the database. An object is represented by the cypher statement: (ob:OBJECT {id: \"10.17616/R3PD38\", name: \"Neotoma Paleoecology Database\", url: \"http://neotomadb.org\", keywords: [\"paleoenvironments\", \"fossil mammals (FAUNMAP)\"], description: \"Neotoma is a multiproxy paleoecological database that covers the Pliocene-Quaternary . . .\"}) Individual databases have keywords associated with them. In some cases keywords may be misspelled, or may be either too general (\"science\") or too specific (\"holocene fossils\"). To ensure that keywords can be used effectively we want to add them to the graph. We do this by creating a special node type (KEYWORD), with the constraint that each keyword is unique. Keywords may be related using the :implies relationship. Each KEYWORD is related to an OBJECT through annotations. schema:CodeRepository \u00b6 Objects of type schema:CodeRepository were originally scraped from GitHub, with code that is found in the github_scrapers repository. The objects have the properties: id which is the repository assigned ID (a numeric identifier in the case of GitHub) name The name of the repository is a combination of the repository owner and the repository name. description A user provided description for the repository. url The URL for the repository. MERGE (ob:OBJECT {id: 1234456, url: \"http://github.com/SimonGoring/myrepo\", description: \"This repo is the bomb of bombs.\", name: \"SimonGoring/myrepo\"}) Code repositories may have keywords assigned, or have keywords defined (topics in the terminology of GitHub). These are linked to KEYWORD objects in the database through an ANNOTATION. schema:Article \u00b6 A scientific journal article type is a simplification of the CrossRef data schema v0.1.1 . The schema for OBJECTs of type schema:Article provides fields for journal, title, author, and URL. The field id is used for the DOI, to keep a standard of unique IDs in the id field. id - Unique identifier for grants (assumes NSF grants) journal title author url MERGE (award:OBJECT {\"journal\": \"Risk Analysis\", \"id\": \"10.1111/risa.13567\", \"title\": \"Protecting From Malware Obfuscation Attacks Through Adversarial Risk Analysis\", \"url\": \"https://onlinelibrary.wiley.com/doi/abs/10.1111/risa.13567\", \"authors\": \"Redondo, Alberto; Insua, David R\u00edos\"}) schema:Grant \u00b6 The structure of a grant is (currently) based on the NSF Award schema. The code to obtain the NSF awards and add them to the graph is located within the Throughput database nsf_award module. AwardID - Unique identifier for grants (assumes NSF grants) name amount ARRAAmount AwardInstrument description MERGE (award:OBJECT {AwardID: 1234567, name: \"Award name\", amount: 12345, ARRAAmount: 12345, AwardInstrument = \"Award Thing\", description = \"The abstract of our grant proposal.\"}) Constraints and Indices \u00b6 There are no constraints or indices on TYPE nodes.","title":"TYPEs"},{"location":"types/types/#types","text":"TYPE is a property of an OBJECT but in practice it is defined as a separate node within the database to allow us to improve the flexibility of the underlying data model. TYPE nodes are defined either as part of the w3C Annotation model (e.g., {type:'TextualBody'} or using other schema, for example {type:'schema:CodeRepository'} . type n schema:Grant 467,000 TextualBody 356,000 schema:Article 159,000 schema:CodeRepository 74,000 schema:DataCatalog 2,300 Dataset 390","title":"TYPEs"},{"location":"types/types/#matching-objects-by-type","text":"Using the TYPE element we can find (for example) a database using: MATCH (tdb:TYPE {type:'schema:DataCatalog'}) MATCH (tdb)<-[:isType]-(n:OBJECT) RETURN n LIMIT 3 The TYPE defining an object also defines some of the properties that the object may have, although these are not embedded as constraints.","title":"Matching Objects by Type"},{"location":"types/types/#various-types","text":"","title":"Various TYPEs"},{"location":"types/types/#schemadatacatalog","text":"Objects defined as data catalogs were initially scraped from re3data.org using a script that has been stored on GitHub in a code repository <http://https://github.com/throughput-ec/throughputdb/tree/master/Re3Databases> _. The object has properties: id , which come from the unique identifier (DOI) assigned by re3data. name is the official name of the database. url is the URL link for the database. keywords is an array of terms associated with the database (although see keywords ) description is the description given to the database. An object is represented by the cypher statement: (ob:OBJECT {id: \"10.17616/R3PD38\", name: \"Neotoma Paleoecology Database\", url: \"http://neotomadb.org\", keywords: [\"paleoenvironments\", \"fossil mammals (FAUNMAP)\"], description: \"Neotoma is a multiproxy paleoecological database that covers the Pliocene-Quaternary . . .\"}) Individual databases have keywords associated with them. In some cases keywords may be misspelled, or may be either too general (\"science\") or too specific (\"holocene fossils\"). To ensure that keywords can be used effectively we want to add them to the graph. We do this by creating a special node type (KEYWORD), with the constraint that each keyword is unique. Keywords may be related using the :implies relationship. Each KEYWORD is related to an OBJECT through annotations.","title":"schema:DataCatalog"},{"location":"types/types/#schemacoderepository","text":"Objects of type schema:CodeRepository were originally scraped from GitHub, with code that is found in the github_scrapers repository. The objects have the properties: id which is the repository assigned ID (a numeric identifier in the case of GitHub) name The name of the repository is a combination of the repository owner and the repository name. description A user provided description for the repository. url The URL for the repository. MERGE (ob:OBJECT {id: 1234456, url: \"http://github.com/SimonGoring/myrepo\", description: \"This repo is the bomb of bombs.\", name: \"SimonGoring/myrepo\"}) Code repositories may have keywords assigned, or have keywords defined (topics in the terminology of GitHub). These are linked to KEYWORD objects in the database through an ANNOTATION.","title":"schema:CodeRepository"},{"location":"types/types/#schemaarticle","text":"A scientific journal article type is a simplification of the CrossRef data schema v0.1.1 . The schema for OBJECTs of type schema:Article provides fields for journal, title, author, and URL. The field id is used for the DOI, to keep a standard of unique IDs in the id field. id - Unique identifier for grants (assumes NSF grants) journal title author url MERGE (award:OBJECT {\"journal\": \"Risk Analysis\", \"id\": \"10.1111/risa.13567\", \"title\": \"Protecting From Malware Obfuscation Attacks Through Adversarial Risk Analysis\", \"url\": \"https://onlinelibrary.wiley.com/doi/abs/10.1111/risa.13567\", \"authors\": \"Redondo, Alberto; Insua, David R\u00edos\"})","title":"schema:Article"},{"location":"types/types/#schemagrant","text":"The structure of a grant is (currently) based on the NSF Award schema. The code to obtain the NSF awards and add them to the graph is located within the Throughput database nsf_award module. AwardID - Unique identifier for grants (assumes NSF grants) name amount ARRAAmount AwardInstrument description MERGE (award:OBJECT {AwardID: 1234567, name: \"Award name\", amount: 12345, ARRAAmount: 12345, AwardInstrument = \"Award Thing\", description = \"The abstract of our grant proposal.\"})","title":"schema:Grant"},{"location":"types/types/#constraints-and-indices","text":"There are no constraints or indices on TYPE nodes.","title":"Constraints and Indices"}]}